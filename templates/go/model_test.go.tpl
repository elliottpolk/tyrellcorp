// Code generated by tyrellcorp. DO NOT EDIT.
// source: model_test.go.tpl

package {{ .Package | ToLower | Trim }}

import (
	"context"
	"strings"
	"testing"
	"time"

	"github.com/google/uuid"
	"github.com/stretchr/testify/assert"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/readpref"
)

const testDbName = "testing_{{ .Name | ToLower | Trim }}"

// NOTE: these tests assume a mongo instance is locally available

// TODO:
// - convert to a real service test
// - include a docker-compose.yml file which:
//   - starts up a mongodb instance
// 	 - runs the tests in a golang:latest container

func dbclient(t *testing.T) (*mongo.Client, func(db string)) {
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	client, err := mongo.NewClient()
	if err != nil {
		t.Fatal(err)
	}

	if err := client.Connect(ctx); err != nil {
		t.Fatal(err)
	}

	if err := client.Ping(ctx, readpref.Primary()); err != nil {
		t.Fatal(err)
	}

	return client, func(db string) {
		ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
		defer cancel()

		if err := client.Database(db).Drop(ctx); err != nil {
			t.Error(err)
		}

		client.Disconnect(ctx)
	}
}

func TestCreate(t *testing.T) {
	items := []*{{ .Name | Trim }}{
		&{{ .Name | Trim }}{
			RecordInfo: &RecordInfo{CreatedBy: "testing"},
			{{ .Name | Trim }}_1:     "But I've never been to the moon! We need rest.",
			{{ .Name | Trim }}_2:     9,
		},
		&{{ .Name | Trim }}{
			RecordInfo: &RecordInfo{CreatedBy: "testing"},
			{{ .Name | Trim }}_1:     "The spirit is willing, but the flesh is spongy and bruised. Incidentally, you have a dime up your nose. And until then, I can never die?",
			{{ .Name | Trim }}_2:     3,
		},
		&{{ .Name | Trim }}{
			RecordInfo: &RecordInfo{CreatedBy: "testing"},
			{{ .Name | Trim }}_1:     "I decline the title of Iron Cook and accept the lesser title of Zinc Saucier, which I just made up. Uhh… also, comes with double prize money. I am the man with no name, Zapp Brannigan! WINDMILLS DO NOT WORK THAT WAY! GOOD NIGHT!",
			{{ .Name | Trim }}_2:     1000000,
		},
	}

	// no need to handle the cancelFunc from the context at this time
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	client, clean := dbclient(t)
	defer clean(testDbName)

	db := client.Database(testDbName)

	if !assert.NoError(t, Create(context.TODO(), items, db)) {
		t.FailNow()
	}

	iter, err := db.Collection(repo).Find(ctx, bson.D{})
	if err != nil {
		t.Fatal(err)
	}
	defer iter.Close(ctx)

	for iter.Next(context.Background()) {
		el := &{{ .Name | Trim }}{}
		assert.NoError(t, iter.Decode(&el))
	}
}

func TestRetrieves(t *testing.T) {
	items := []*{{ .Name | Trim }}{
		&{{ .Name | Trim }}{
			Id:         uuid.New().String(),
			RecordInfo: &RecordInfo{CreatedBy: "testing"},
			{{ .Name | Trim }}_1:     "But I've never been to the moon! We need rest.",
			{{ .Name | Trim }}_2:     9,
		},
		&{{ .Name | Trim }}{
			Id:         uuid.New().String(),
			RecordInfo: &RecordInfo{CreatedBy: "testing"},
			{{ .Name | Trim }}_1:     "The spirit is willing, but the flesh is spongy and bruised. Incidentally, you have a dime up your nose. And until then, I can never die?",
			{{ .Name | Trim }}_2:     3,
		},
		&{{ .Name | Trim }}{
			Id:         uuid.New().String(),
			RecordInfo: &RecordInfo{CreatedBy: "testing"},
			{{ .Name | Trim }}_1:     "I decline the title of Iron Cook and accept the lesser title of Zinc Saucier, which I just made up. Uhh… also, comes with double prize money. I am the man with no name, Zapp Brannigan! WINDMILLS DO NOT WORK THAT WAY! GOOD NIGHT!",
			{{ .Name | Trim }}_2:     1000000,
		},
	}

	client, clean := dbclient(t)
	defer clean(testDbName)

	db := client.Database(testDbName)

	// warm with test data
	if !assert.NoError(t, Create(context.TODO(), items, db)) {
		t.FailNow()
	}

	item := items[0]

	res0, err := RetrieveOne(context.TODO(), item.Id, db)
	if err != nil {
		t.Fatal(err)
	}

	assert.Equal(t, item.Id, res0.Id)
	assert.Equal(t, item.{{ .Name | Trim }}_1, res0.{{ .Name | Trim }}_1)

	res1, err := Retrieve(context.TODO(), {{ `bson.D{{"dope_2", bson.D{{"$lt", 999999}}}}` }}, db)
	if err != nil {
		t.Fatal(err)
	}

	assert.Equal(t, 2, len(res1))

	res2, err := Retrieve(context.TODO(), {{ `bson.D{{"dope_2", 200}}` }}, db)
	if err != nil {
		t.Fatal(err)
	}

	assert.Empty(t, res2)
	assert.Len(t, res2, 0)
}

func TestUpdate(t *testing.T) {
	items := []*{{ .Name | Trim }}{
		&{{ .Name | Trim }}{
			Id:         uuid.New().String(),
			RecordInfo: &RecordInfo{CreatedBy: "testing"},
			{{ .Name | Trim }}_1:     "But I've never been to the moon! We need rest.",
			{{ .Name | Trim }}_2:     9,
		},
		&{{ .Name | Trim }}{
			Id:         uuid.New().String(),
			RecordInfo: &RecordInfo{CreatedBy: "testing"},
			{{ .Name | Trim }}_1:     "The spirit is willing, but the flesh is spongy and bruised. Incidentally, you have a dime up your nose. And until then, I can never die?",
			{{ .Name | Trim }}_2:     3,
		},
		&{{ .Name | Trim }}{
			Id:         uuid.New().String(),
			RecordInfo: &RecordInfo{CreatedBy: "testing"},
			{{ .Name | Trim }}_1:     "I decline the title of Iron Cook and accept the lesser title of Zinc Saucier, which I just made up. Uhh… also, comes with double prize money. I am the man with no name, Zapp Brannigan! WINDMILLS DO NOT WORK THAT WAY! GOOD NIGHT!",
			{{ .Name | Trim }}_2:     1000000,
		},
	}

	item := items[0]

	client, clean := dbclient(t)
	defer clean(testDbName)

	db := client.Database(testDbName)

	// warm with test data
	if !assert.NoError(t, Create(context.TODO(), items, db)) {
		t.FailNow()
	}

	item.{{ .Name | Trim }}_1 = "You are the last hope of the universe. Why not indeed! Aww, it's true. I've been hiding it for so long. Well, then good news! It's a suppository. OK, if everyone's finished being stupid."
	res0, err := RetrieveOne(context.TODO(), item.Id, db)
	if err != nil {
		t.Fatal(err)
	}
	assert.NotEqual(t, item.{{ .Name | Trim }}_1, res0.{{ .Name | Trim }}_1)

	if !assert.NoError(t, Update(context.TODO(), "fake_user", bson.D{}, items[0:1], db)) {
		t.FailNow()
	}

	res1, err := RetrieveOne(context.TODO(), item.Id, db)
	if err != nil {
		t.Fatal(err)
	}
	assert.Equal(t, item.{{ .Name | Trim }}_1, res1.{{ .Name | Trim }}_1)
	assert.NotEqual(t, res0.{{ .Name | Trim }}_1, res1.{{ .Name | Trim }}_1)
}

func TestDelete(t *testing.T) {

	items := []*{{ .Name | Trim }}{
		&{{ .Name | Trim }}{
			Id:         uuid.New().String(),
			RecordInfo: &RecordInfo{CreatedBy: "testing"},
			{{ .Name | Trim }}_1:     "But I've never been to the moon! We need rest.",
			{{ .Name | Trim }}_2:     9,
		},
		&{{ .Name | Trim }}{
			Id:         uuid.New().String(),
			RecordInfo: &RecordInfo{CreatedBy: "testing"},
			{{ .Name | Trim }}_1:     "The spirit is willing, but the flesh is spongy and bruised. Incidentally, you have a dime up your nose. And until then, I can never die?",
			{{ .Name | Trim }}_2:     3,
		},
		&{{ .Name | Trim }}{
			Id:         uuid.New().String(),
			RecordInfo: &RecordInfo{CreatedBy: "testing"},
			{{ .Name | Trim }}_1:     "I decline the title of Iron Cook and accept the lesser title of Zinc Saucier, which I just made up. Uhh… also, comes with double prize money. I am the man with no name, Zapp Brannigan! WINDMILLS DO NOT WORK THAT WAY! GOOD NIGHT!",
			{{ .Name | Trim }}_2:     1000000,
		},
	}

	client, clean := dbclient(t)
	defer clean(testDbName)

	db := client.Database(testDbName)

	if err := Delete(context.TODO(), "fake_user", items, db); err != nil {
		if !strings.HasSuffix(err.Error(), ErrIncompleteAction.Error()) {
			t.Fatal(err)
		}
	}

	// warm with test data
	if !assert.NoError(t, Create(context.TODO(), items, db)) {
		t.FailNow()
	}

	assert.NoError(t, Delete(context.TODO(), "fake_user", items[0:1], db))

	res0, err := Retrieve(context.TODO(), bson.D{}, db)
	if err != nil {
		t.Fatal(err)
	}

	assert.NotEmpty(t, res0)
	assert.Len(t, res0, 2)

	if err := Delete(context.TODO(), "fake_user", items, db); err != nil {
		if !strings.HasSuffix(err.Error(), ErrIncompleteAction.Error()) {
			t.Fatal(err)
		}
	}

	res1, err := Retrieve(context.TODO(), bson.D{}, db)
	if err != nil {
		t.Fatal(err)
	}

	assert.Empty(t, res1)
	assert.Len(t, res1, 0)
}
